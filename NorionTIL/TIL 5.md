# Reason : 

**왜 해?**

왜 내가 아는 파일이름이 왜 계정 이름인가 궁금했어

- [x] 왜 bin이라는 계정 명을 쓰는지
# Action : 

**뭘 했어?**

조사했어

bin이라는 계정명을 쓰는 이유는 시스템계정이여 그래

<details>
<summary>그럼 시스템 계정이 뭔데</summary>

    시스템 운영관리에 필요한 프로세스나 서비스 실행하기 위한 존재래

</details>

<details>
<summary>그럼 bin은 뭐하는 계정인데</summary>

    bin은 실행파일을 실행시키고 가지고 있는 파일 이면서 시스템 계정이야, 근데 초창기 리눅스에서만 쓰고 지금은 안써

    <details>
    <summary>근데 그럼 왜 있는건데, 안쓰는데</summary>

        역호환성이라고 해서 초창기 리눅스에서 썼던 S/W를 지금에서도 쓰기 위해서 남겨 놓는거야

    </details>

    <details>
    <summary>왜 bin을 지금은 안써? 어떻게 리눅스가 바뀌었길래?</summary>

        초기 유닉스는 작업분리를 통해 효율성을 강조함

        <details>
        <summary>작업분리</summary>

        </details>

        bin 파일을 관리하는 bin 계정을 만들어서 root와 분리된 권한으로 관리 하려고함

    </details>

</details>

# Insight : 

**뭘 느꼈어?**

리눅스 잘 만들었다

나중에 호환성을 위해서 옛설계를 남겨 둔다는 부분이 아까워? 비효율적이라고 생각하면서 또 그럴 수 있겠다고 생각한다.

만약에 그 옛설계를 가상화 시켜서 관리 할 수는 없나? jvm 처럼, 옛프로그램을 사용할때는 가상의 옛설계를 갖다가 끼우고 결과 값을 현재 프로그램에 호출하는것

## 잘한점

기본으로 있는 것에 궁금증을 둔 것

## 개선점

집중력이 10분이 안된다

## 배울점

역호환성, 옛날 소프트웨어와 호환 하기 위해 설계한것
